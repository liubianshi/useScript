<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>linux shell 字符串替换_yi412的专栏-CSDN博客</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
        body {
            margin: 40px auto;
            max-width: 650px;
            padding: 0 10px;
            background: #282828;
            color: #ebdbb2;
        }
        h1, h2, h3 {
            line-height: 1.5;
        }
        p {
            font-family: 'TsangerJinKai01\-9128 W03',
                         'Fira Sans', 'Noto Sans',
                         -apple-system, 'Source Han Sans CN',
                         'Noto Sans CJK SC', sans-serif !important;
            font-size: 14px !important;
            letter-spacing: 0.05ex;
            line-height: 2 !important;
        }
        a {
            color: #458588;
        }
        img {
            max-width: 526px;
        }
        p img {
            margin: auto;
            display: block;
        }
        .entry-content {
            font-size: 14px;
            line-height: 2;
        }
    </style>
</head>
<div id="readabilityBody">
            
                            <div class="htmledit_views" id="content_views">
                                            
<span>%x=abcdabcd<br/>
%echo ${x/a/b} # 只替换一个<br/>
bbcdabcd<br/>
%echo ${x//a/b} # 替换所有<br/></span>






<p>引用 参考  http://www.cnblogs.com/chengmo/archive/2010/10/02/1841355.html<br/></p>

<p>在做shell批处理程序时候，经常会涉及到字符串相关操作。有很多命令语句，如：awk,sed都可以做字符串各种操作。 其实shell内置一系列操作符号，可以达到类似效果，大家知道，使用内部操作符会省略启动外部程序等时间，因此速度会非常的快。</p>


<blockquote>
<p class="table-box"><table border="0" cellspacing="1" cellpadding="4" bgcolor="#666666" width="476"><colgroup><col/><col/></colgroup><thead><tr><th bgcolor="#cccccc">表达式</th>
<th bgcolor="#cccccc" width="347">含义</th>
</tr></thead><tbody><tr><td bgcolor="#ffffff">${var}</td>
<td bgcolor="#ffffff" width="347">变量var的值, 与$var相同</td>
</tr><tr><td bgcolor="#ffffff"> </td>
<td bgcolor="#ffffff" width="347"> </td>
</tr><tr><td bgcolor="#ffffff">${var-DEFAULT}</td>
<td bgcolor="#ffffff" width="347">如果var没有被声明, 那么就以$DEFAULT作为其值 *</td>
</tr><tr><td bgcolor="#ffffff">${var:-DEFAULT}</td>
<td bgcolor="#ffffff" width="347">如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 *</td>
</tr><tr><td bgcolor="#ffffff"> </td>
<td bgcolor="#ffffff" width="347"> </td>
</tr><tr><td bgcolor="#ffffff">${var=DEFAULT}</td>
<td bgcolor="#ffffff" width="347">如果var没有被声明, 那么就以$DEFAULT作为其值 *</td>
</tr><tr><td bgcolor="#ffffff">${var:=DEFAULT}</td>
<td bgcolor="#ffffff" width="347">如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 *</td>
</tr><tr><td bgcolor="#ffffff"> </td>
<td bgcolor="#ffffff" width="347"> </td>
</tr><tr><td bgcolor="#ffffff">${var+OTHER}</td>
<td bgcolor="#ffffff" width="347">如果var声明了, 那么其值就是$OTHER, 否则就为null字符串</td>
</tr><tr><td bgcolor="#ffffff">${var:+OTHER}</td>
<td bgcolor="#ffffff" width="347">如果var被设置了, 那么其值就是$OTHER, 否则就为null字符串</td>
</tr><tr><td bgcolor="#ffffff"> </td>
<td bgcolor="#ffffff" width="347"> </td>
</tr><tr><td bgcolor="#ffffff">${var?ERR_MSG}</td>
<td bgcolor="#ffffff" width="347">如果var没被声明, 那么就打印$ERR_MSG *</td>
</tr><tr><td bgcolor="#ffffff">${var:?ERR_MSG}</td>
<td bgcolor="#ffffff" width="347">如果var没被设置, 那么就打印$ERR_MSG *</td>
</tr><tr><td bgcolor="#ffffff"> </td>
<td bgcolor="#ffffff" width="347"> </td>
</tr><tr><td bgcolor="#ffffff">${!varprefix*}</td>
<td bgcolor="#ffffff" width="347">匹配之前所有以varprefix开头进行声明的变量</td>
</tr><tr><td bgcolor="#ffffff">${!varprefix@}</td>
<td bgcolor="#ffffff" width="347">匹配之前所有以varprefix开头进行声明的变量</td>
</tr></tbody></table></p></blockquote>
<p><span>加入了“*”  不是意思是： 当然, 如果变量var已经被设置的话, 那么其值就是$var.</span></p>
<blockquote>
<p>[chengmo@localhost ~]$ echo ${abc-'ok'}<br/>
ok<br/>
[chengmo@localhost ~]$ echo $abc </p>
<p>[chengmo@localhost ~]$ echo ${abc='ok'}<br/>
ok<br/>
[chengmo@localhost ~]$ echo $abc<br/>
ok </p>


<p>[chengmo@localhost ~]$ var1=11;var2=12;var3=<br/>
[chengmo@localhost ~]$ echo ${!v@}            <br/>
var1 var2 var3<br/>
[chengmo@localhost ~]$ echo ${!v*}<br/>
var1 var2 var3 </p>

<p><span>${!varprefix*}与${!varprefix@}相似，可以通过变量名前缀字符，搜索已经定义的变量,无论是否为空值。</span></p>
</blockquote>


<blockquote>
<p class="table-box"><table border="0" cellspacing="1" cellpadding="4" bgcolor="#333333" width="462"><colgroup><col/><col/></colgroup><thead><tr><th bgcolor="#cccccc">表达式</th>
<th bgcolor="#cccccc" width="229">含义</th>
</tr></thead><tbody><tr><td bgcolor="#ffffff">${#string}</td>
<td bgcolor="#ffffff" width="229">$string的长度</td>
</tr><tr><td bgcolor="#ffffff"> </td>
<td bgcolor="#ffffff" width="229"> </td>
</tr><tr><td bgcolor="#ffffff">${string:position}</td>
<td bgcolor="#ffffff" width="229">在$string中, 从位置$position开始提取子串</td>
</tr><tr><td bgcolor="#ffffff">${string:position:length}</td>
<td bgcolor="#ffffff" width="229">在$string中, 从位置$position开始提取长度为$length的子串</td>
</tr><tr><td bgcolor="#ffffff"> </td>
<td bgcolor="#ffffff" width="229"> </td>
</tr><tr><td bgcolor="#ffffff">${string#substring}</td>
<td bgcolor="#ffffff" width="229">从变量$string的开头, 删除最短匹配$substring的子串</td>
</tr><tr><td bgcolor="#ffffff">${string##substring}</td>
<td bgcolor="#ffffff" width="229">从变量$string的开头, 删除最长匹配$substring的子串</td>
</tr><tr><td bgcolor="#ffffff">${string%substring}</td>
<td bgcolor="#ffffff" width="229">从变量$string的结尾, 删除最短匹配$substring的子串</td>
</tr><tr><td bgcolor="#ffffff">${string%%substring}</td>
<td bgcolor="#ffffff" width="229">从变量$string的结尾, 删除最长匹配$substring的子串</td>
</tr><tr><td bgcolor="#ffffff"> </td>
<td bgcolor="#ffffff" width="229"> </td>
</tr><tr><td bgcolor="#ffffff">${string/substring/replacement}</td>
<td bgcolor="#ffffff" width="229">使用$replacement, 来代替第一个匹配的$substring</td>
</tr><tr><td bgcolor="#ffffff">${string//substring/replacement}</td>
<td bgcolor="#ffffff" width="229">使用$replacement, 代替<em>所有</em>匹配的$substring</td>
</tr><tr><td bgcolor="#ffffff">${string/#substring/replacement}</td>
<td bgcolor="#ffffff" width="229">如果$string的<em>前缀</em>匹配$substring, 那么就用$replacement来代替匹配到的$substring</td>
</tr><tr><td bgcolor="#ffffff">${string/%substring/replacement}</td>
<td bgcolor="#ffffff" width="229">如果$string的<em>后缀</em>匹配$substring, 那么就用$replacement来代替匹配到的$substring</td>
</tr><tr><td bgcolor="#ffffff"> </td>
<td bgcolor="#ffffff" width="229"> </td>
</tr></tbody></table></p></blockquote>
<p><span><strong>说明："*</strong> $substring”可以是一个<em>正则表达式</em>.</span></p>

<blockquote>

<p>[web97@salewell97 ~]$ test='I love china'<br/>
[web97@salewell97 ~]$ echo ${#test}<br/>
12 </p>



<p>[chengmo@localhost ~]$ test='I love china'<br/>
[chengmo@localhost ~]$ echo ${test:5}     <br/>
e china<br/>
[chengmo@localhost ~]$ echo ${test:5:10} <br/>
e china </p>



<p>[chengmo@localhost ~]$ test='c:/windows/boot.ini'<br/>
[chengmo@localhost ~]$ echo ${test#/}<br/>
c:/windows/boot.ini<br/>
[chengmo@localhost ~]$ echo ${test#*/}<br/>
windows/boot.ini<br/>
[chengmo@localhost ~]$ echo ${test##*/}<br/>
boot.ini </p>
<p>[chengmo@localhost ~]$ echo ${test%/*} <br/>
c:/windows<br/>
[chengmo@localhost ~]$ echo ${test%%/*} </p>
<p>${变量名#substring正则表达式}从字符串开头开始配备substring,删除匹配上的表达式。 </p>
<p>${变量名%substring正则表达式}从字符串结尾开始配备substring,删除匹配上的表达式。 </p>
<p>注意：${test##*/},${test%/*} 分别是得到文件名，或者目录地址最简单方法。 </p>

<p>[chengmo@localhost ~]$ test='c:/windows/boot.ini'<br/>
[chengmo@localhost ~]$ echo ${test/\//\\}<br/>
c:\windows/boot.ini<br/>
[chengmo@localhost ~]$ echo ${test//\//\\}<br/>
c:\windows\boot.ini </p>

<p>${变量/查找/替换值} 一个“/”表示替换第一个，”//”表示替换所有,当查找中出现了：”/”请加转义符”\/”表示。</p>
</blockquote>

<blockquote>
<p>在shell中，通过awk,sed,expr 等都可以实现，字符串上述操作。下面我们进行性能比较。 </p>
<p>[chengmo@localhost ~]$ test='c:/windows/boot.ini'                       <br/>
[chengmo@localhost ~]$ time for i in $(seq 10000);do a=${#test};done;            </p>
<p>real    0m0.173s<br/>
user    0m0.139s<br/>
sys     0m0.004s </p>
<p>[chengmo@localhost ~]$ time for i in $(seq 10000);do a=$(expr length $test);done;      </p>
<p>real    0m9.734s<br/>
user    0m1.628s </p>

<p><span>速度相差上百倍，调用外部命令处理，与内置操作符性能相差非常大。在shell编程中，尽量用内置操作符或者函数完成。使用awk,sed类似会出现这样结果。</span></p>
</blockquote>
                                    </div>
                                
            </div></html>